#! /usr/bin/env python
'''
sunny-cp executable module.
'''

import os
import sys
import time
import fcntl
import psutil
import signal
import traceback
import multiprocessing
from string import replace
from socket import gethostname
from subprocess import PIPE

SUNNY_HOME = os.environ['SUNNY_HOME']
sys.path.append(SUNNY_HOME + '/src')
from problem        import *
from parsing        import *
from solver         import *
from features       import *
from scheduling     import *
from pfolio_solvers import *

# List of the running solvers.
RUNNING_SOLVERS = []
# List of the suspended solvers.
SUSP_SOLVERS = []
# If KEEP, don't delete temporary files.
KEEP = False
# List of temporary file paths.
TMP_FILES = []
# Sleep time (in seconds) for multiprocessing.
SLEEP_TIME = 0.1

def handler(signum = None, frame = None):
  """
  Handles termination signals.
  """
  print >> sys.stderr, '% Signal handler called with signal',signum
  clean()
  sys.stdout.close()
  sys.exit(signum)
for sig in [signal.SIGTERM, signal.SIGINT, signal.SIGHUP, signal.SIGQUIT]:
  signal.signal(sig, handler)

def send_signal_solver(signal, solver):
  """
  Sends the specified signal to the solver process, and to all its childs.
  """
  proc = solver.process
  if proc.poll() is None:
    for p in proc.children(recursive = True):
      try:
        p.send_signal(signal)
      except psutil.NoSuchProcess:
	pass
    try:
      proc.send_signal(signal)
    except psutil.NoSuchProcess:
      pass

def clean():
  """
  Utility for (possibly) cleaning temporary files and killing the solvers 
  processes at the end of the solving process (even when the termination is 
  forced externally).
  """
  global RUNNING_SOLVERS, SUSP_SOLVERS
  for solver in RUNNING_SOLVERS + SUSP_SOLVERS:
    send_signal_solver(signal.SIGKILL, solver)
  # Possibly remove temporary files.
  if not KEEP:
    for f in TMP_FILES:
      if os.path.exists(f):
        os.remove(f)

def run_schedule(
  schedule, problem, cores, mem_limit, 
  presolve = False, extractor = None, k = 0, kb = None, lims = None
):
  """
  Runs (possibly in parallel on different cores) a schedule of solvers.
  Note that this function is used for both the static and the dynamic schedule.
  If it is used for static schedule, the flag "presolve" must be set to True. 
  If presolve = True, it is also possible to perform the k-Nearest Neighbours 
  computation of the input problem by setting the "extractor", "k", "kb", and 
  "lims" parameters. The neighbours are computed as soon as a free core is 
  available. If presolve = True this function returns a triplet (t, n, b) where:
    - t  is the time taken by the presolve phase;
    - n  is the (possibly empty) neighborhood of the problem;
    - b  is the (possibly empry) black list of the name of the solvers that 
         failed during the pre-solving fase.
  """
  global RUNNING_SOLVERS, SUSP_SOLVERS
  if presolve:
    start_time = time.time()
    black_list = []
    neighbours = []
    neigh_computed = False
    
  # Launch the solvers (if any).
  for _ in range(cores):
    if schedule:
      solver = schedule.pop(0)
      run_solver(solver, problem)
      
  # Loop for dealing with solvers execution.
  while (presolve and not neigh_computed) or RUNNING_SOLVERS:
    time.sleep(SLEEP_TIME)
    
    if presolve and not neigh_computed and len(RUNNING_SOLVERS) < cores:
      print '% Extracting features...'
      feat_vector = extractor.extract_features([problem, lims])
      if feat_vector:
	print '% Computing the',k,'nearest neighbors of the problem'
        neighbours = get_neighbours(feat_vector, k, kb)
      else:
	print '% Features extraction failed!'
      neigh_computed = True

    if mem_limit < 100:
      mems = dict((s, s.mem_percent()) for s in RUNNING_SOLVERS)
      if sum(mems.values()) > mem_limit:
	solver = max(mems.items(), key = lambda x: x[1])[0]
	print '% Warning! sunny-cp exceeded the maximum allowed memory'
	print '% Killing solver',solver.name()
	send_signal_solver(signal.SIGKILL, solver)
	RUNNING_SOLVERS.remove(solver)
        continue
    
    for solver in RUNNING_SOLVERS:
      # Read and process lines from the output stream of each process.
      lines = read_lines(solver.process)
      if lines:
	process_output(solver, problem, lines)
      
      # Solver process terminated.
      if solver.process.poll() is not None:
	if solver.status == 'flatzinc':
	  # Sometimes not all the lines are read from solver output.
	  lines = read_lines(solver.process)  
          if lines:
	    process_output(solver, problem, lines)
        solver_terminated(solver, problem, schedule)
        if presolve and solver.process.returncode not in [None, 0]:
	  black_list.append(solver.name())
        continue
      
      # Expired timeout: the solver has to be suspended.
      if time.time() - solver.start_time > solver.timeout and \
	 time.time() - solver.solution_time > solver.wait_time:
	   solver_timeout(solver, problem, schedule)
	   continue
	 
      # Restart a solver if its solution is obsolete and its restart time is 
      # actually expired.
      if solver.status == 'flatzinc' \
      and problem.bound_better_than(solver.obj_value) \
      and time.time() - solver.solution_time > solver.restart_time:
	send_signal_solver(signal.SIGKILL, solver)
	RUNNING_SOLVERS.remove(solver)
	print '% Restarting',solver.name()
	solver.timeout = max(
	  solver.timeout - (time.time() - solver.start_time), 0
	)
	run_solver(solver, problem)
	continue

  if presolve:
    return neighbours, time.time() - start_time, black_list

def run_solver(solver, problem):
  """
  Executes a solver according to its status.
  """
  global RUNNING_SOLVERS, SUSP_SOLVERS
  susp = [s for s in SUSP_SOLVERS if s.name() == solver.name()]
  if susp:
    solver = susp[0]
    SUSP_SOLVERS.remove(solver)
    resume_solver(solver, solver.timeout)
    return
  if solver.status == 'ready':
    print '% Starting',solver.name(),'for',str(solver.timeout),'seconds'
    cmd = solver.mzn2fzn_cmd(problem)
    solver.status = 'mzn2fzn'
  elif solver.status == 'mzn2fzn':
    cmd = solver.flatzinc_cmd(problem)
    solver.status = 'flatzinc'
  elif solver.status == 'flatzinc':
    if problem.isCOP() and not solver.obj_var:
      # Extract and set the objective variable from the FlatZinc model.
      solver.set_obj_var()
    if solver.name() == problem.best_solver or \
    problem.bound_better_than(solver.obj_value):
      # Starts the solver with a better bound.
      bound = problem.best_bound
      print '% Injecting value',bound,'to',solver.name(),'FlatZinc model'
      solver.inject_bound(bound)
    cmd = solver.flatzinc_cmd(problem)
  else:
    print '% Unknown status',solver.status
    assert False
  
  if solver.status == 'flatzinc':
    solver.process = psutil.Popen(cmd, stdout = PIPE)
    # For non-blocking read.
    fd = solver.process.stdout.fileno()
    fl = fcntl.fcntl(fd, fcntl.F_GETFL)
    fcntl.fcntl(fd, fcntl.F_SETFL, fl | os.O_NONBLOCK)
  else:
    solver.process = psutil.Popen(cmd)
  solver.start_time = time.time()
  solver.solution_time = time.time()
  RUNNING_SOLVERS.append(solver)

def read_lines(proc):
  """
  Returns the stream of the read lines of a process.
  """
  try:
    return proc.stdout.read()
  except:
    return ''

def process_output(solver, problem, lines):
  """
  Processes the output of a solver.
  """
  for line in lines.split('\n'):
    if line == '----------':
      if problem.isCSP():
	print '%',solver.name(),'found a solution'
	for (var, val) in solver.solution.items():
	  print var,'=',val
	print line
	if '-a ' not in solver.fzn_options and ' -a ' not in solver.fzn_options:
	  print '% Search completed by',solver.name()
	  clean()
          sys.exit(0)
      elif problem.bound_worse_than(solver.obj_value):
	# The objective value found is the best so far.
	problem.best_bound = solver.obj_value
	print '%',solver.name(),'found a new solution'
	for (var, val) in solver.solution.items():
	  if var == problem.aux_var:
	    print '%',var,'=',val
	  else:
	    print var,'=',val
	print line
	problem.best_solver = solver.name()
      solver.solution = {}
      solver.solution_time = time.time()
    elif line == '==========' or line == '=====UNSATISFIABLE=====':
      if not problem.has_bound():
	print line
      else:
	print '=========='
      print '% Search completed by',solver.name()
      clean()
      sys.exit(0)
    elif ' = ' in line:
      idx = line.index(' = ')
      val = line[idx + 3:].split(';')[0]
      var = line[:idx]
      if var == problem.aux_var:
	solver.obj_value = int(val)
      solver.solution[var] = val
      solver.solution_time = time.time()

def solver_terminated(solver, problem, schedule):
  """
  Handles the termination of a solver process, possibly launching a new solver.
  """
  global RUNNING_SOLVERS, SUSP_SOLVERS
  RUNNING_SOLVERS.remove(solver)
  if solver.status == 'mzn2fzn':
    if solver.process.returncode == 0:
      print '% MiniZinc model converted by ' + solver.name() + '.',
      timeout = max(solver.timeout - (time.time() - solver.start_time), 0)
      print 'Starting the FlatZinc execution for',str(timeout),'seconds'
      solver.timeout = timeout
      run_solver(solver, problem)
    else:
      print '% Error! MiniZinc model not converted by',solver.name()
      # Launch a new solver if any.
      for s in schedule + SUSP_SOLVERS:
	if s.name() == solver.name():
	  schedule.remove(s)
	  if s.status != 'ready':
	    send_signal_solver(signal.SIGKILL, solver)
      if schedule:
	new_solver = schedule.pop(0)
	new_solver.timeout += solver.timeout + solver.start_time - time.time()
	run_solver(new_solver, problem)
      elif SUSP_SOLVERS:
	new_solver = SUSP_SOLVERS.pop(0)
	new_timeout = \
	  new_solver.timeout + solver.timeout + solver.start_time - time.time()
	resume_solver(new_solver, new_timeout)
  else:
    if solver.process.returncode not in [None, 0]:
      # Premature termination of solver execution.
      print '% Solver',solver.name(),'failed prematurely'
      for s in schedule + SUSP_SOLVERS:
	if s.name() == solver.name():
	  schedule.remove(s)
	  if s.status != 'ready':
	    send_signal_solver(signal.SIGKILL, solver)
    # Launch a new solver if any.
    if schedule:
      new_solver = schedule.pop(0)
      new_solver.timeout += solver.timeout + solver.start_time - time.time()
      run_solver(new_solver, problem)
    elif SUSP_SOLVERS:
      new_solver = SUSP_SOLVERS.pop(0)
      new_timeout = \
	new_solver.timeout + solver.timeout + solver.start_time - time.time()
      resume_solver(new_solver, new_timeout)

def solver_timeout(solver, problem, schedule):
  """
  Handles the timeout of a solver process, possibly launching a new solver.
  """
  global RUNNING_SOLVERS, SUSP_SOLVERS
  print '% Timeout expired for',solver.name()
  if schedule:
    new_solver = schedule.pop(0)
    if new_solver.timeout == 0:
      # In this case, all the scheduled solvers have been run (or are running on
      # another core). This happens at time t >= T, where T is the timeout T of 
      # the SUNNY algorithm.
      if len(RUNNING_SOLVERS) == 1:
	print '% Solver not interrupted: it is the only running solver'
	solver.timeout = float("+inf")
      elif solver.name() == problem.best_solver:
	print '% Solver not interrupted: it is the best one so far'
	solver.timeout = float("+inf")
      else:
	send_signal_solver(signal.SIGKILL, solver)
	RUNNING_SOLVERS.remove(solver)
	susp = [
	  s for s in SUSP_SOLVERS if s.name() == problem.best_solver
	]
	if susp:
	  # Resuming the best solver so far, it it was suspended.
	  resume_solver(susp[0], float("+inf"))
	# The schedule is no more needed.
	schedule = []
	for solver in SUSP_SOLVERS:
	  send_signal_solver(signal.SIGKILL, solver)
	SUSP_SOLVERS = []
    else:
      if new_solver.name() != solver.name():
	suspend_solver(solver)
	run_solver(new_solver, problem)
      else:
	print '% Solver',solver.name(),'not interrupted: it has to run again.'
  else:
    suspend_solver(solver)

def suspend_solver(solver):
  """
  Suspends a solver that reached its timeout.
  """
  global RUNNING_SOLVERS, SUSP_SOLVERS
  print '% Suspending solver',solver.name()
  send_signal_solver(signal.SIGSTOP, solver)
  SUSP_SOLVERS.append(solver)
  RUNNING_SOLVERS.remove(solver)
  
def resume_solver(solver, timeout):
  """
  Resumes a solver, and run it for timeout seconds.
  """
  global RUNNING_SOLVERS
  print '% Resuming solver',solver.name(),'for',str(timeout),'seconds'
  solver.timeout = timeout
  send_signal_solver(signal.SIGCONT, solver)
  solver.start_time = time.time()
  solver.solution_time = time.time()
  RUNNING_SOLVERS.append(solver)

def init_problem(problem, tmp_id):
  """
  Initializes a problem, making it ready to be solved.
  """
  global TMP_FILES
  ozn_path = tmp_id + '.ozn'
  problem.ozn_path = ozn_path
  TMP_FILES = [ozn_path]
  if problem.isCOP():
    # Make a copy of the original MiniZinc model.
    mzn_path = tmp_id + '.mzn'
    out_path = tmp_id + '.out'
    problem = problem.make_cpy(mzn_path, out_path, aux = True)
    TMP_FILES += [mzn_path, out_path]
  return problem

def init_schedule(schedule, solver_options, solve, tmp_id):
  """
  Initializes a schedule, making it ready to be executed.
  """
  global TMP_FILES
  running_schedule = []  
  for (s, t) in schedule:
    fzn_path = tmp_id + '.' + s + '.fzn'
    opts = solver_options[s]['options']
    wt   = float(solver_options[s]['wait_time'])
    rt   = solver_options[s]['restart_time']
    solver = RunningSolver(eval(s), solve, fzn_path, opts, wt, rt, t)
    running_schedule.append(solver)
    TMP_FILES.append(fzn_path)
  return running_schedule

def main(args):
  global KEEP
  try:
    # Input arguments parsing and initialization.
    problem, k, timeout, pfolio, backup, kb, lims, static, extractor, cores, \
    solver_options, tmp_dir, mem_limit, KEEP = parse_arguments(args)
    tmp_id = tmp_dir + '/' + gethostname() + '_' + str(os.getpid())
    problem = init_problem(problem, tmp_id)
    static  = init_schedule(static, solver_options, problem.solve, tmp_id)
    
    print '%%%%% Pre-solving %%%%%'
    if cores >= len(pfolio):
      # If the number of specified cores exceeds the portfolio size, then no 
      # prediction is needed: we simply allocate a core per solver.
      print '% Features extraction not needed!'
      extractor = None
      lims = None
    neighbours, static_time, black_list = run_schedule(
      static, problem, cores, mem_limit, True, extractor, k, kb, lims
    )
    
    print '%%%%% Solving %%%%%'
    pfolio = [s for s in pfolio if s not in black_list]
    if not neighbours or len(pfolio) <= cores:
      if len(pfolio) <= cores:
	print '% Portfolio size <= No. of cores: no prediction needed!'
      print '% Switching to backup solver(s)'
      par_sched = [(s, float('+inf')) for s in pfolio[:cores]]
    else:
      print '% Computing solvers schedule...'
      timeout -= round(static_time)
      if problem.isCSP():
	seq_sched = sunny_csp(neighbours, k, timeout, pfolio, backup, cores)
      else:
	seq_sched = sunny_cop(neighbours, k, timeout, pfolio, backup, cores)
      print '% SUNNY sequential schedule:',seq_sched
      if len(seq_sched) <= cores:
	print '% Schedule size <= No. of cores! No re-scheduling needed!'
	par_sched = [(s, float('+inf')) for (s, t) in 
	  sorted(seq_sched, key = lambda x : x[0], reverse = True)
	]
	not_sched = [
	  (s, float('+inf')) for s in pfolio if s not in dict(par_sched).keys()
	]
	par_sched += not_sched[:cores - len(seq_sched)]
      else:
	print '% Parallelizing schedule on',cores,'cores'
        par_sched = parallelize(seq_sched, cores, timeout)
    par_sched += [(s, 0) for s in pfolio if s not in dict(par_sched).keys()]
    print '% SUNNY parallel schedule:',par_sched    
    schedule = init_schedule(par_sched, solver_options, problem.solve, tmp_id)
    run_schedule(schedule, problem, cores, mem_limit)
    
  except Exception as e:
    print >> sys.stderr, '% Unexpected Termination of sunny-cp.'
    clean()
    traceback.print_exc()
    sys.exit(1)
    
  print '% Search not completed by any constituent solver. Bye!!!'
  clean()
  
if __name__ == '__main__':
  main(sys.argv[1:])
