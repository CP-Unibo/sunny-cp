#! /usr/bin/env python
'''
sunny-cp executable module.
'''

import os
import sys
import time
import fcntl
import psutil
import signal
import traceback
import multiprocessing
from string import replace
from socket import gethostname
from subprocess import Popen, PIPE

SUNNY_HOME = os.environ['SUNNY_HOME']
sys.path.append(SUNNY_HOME + '/src')
from problem        import *
from parsing        import *
from solver         import *
from features       import *
from scheduling     import *
from pfolio_solvers import *

# List of the running solvers.
RUNNING_SOLVERS = []
# If KEEP, don't delete temporary files.
KEEP = False
# List of temporary file paths.
TMP_FILES = []
# Sleep time (in seconds) for multiprocessing.
SLEEP_TIME = 0.1

def handler(signum = None, frame = None):
  """
  Handles termination signals.
  """
  print >> sys.stderr, '% Signal handler called with signal',signum
  clean()
  sys.stdout.close()
  sys.exit(signum)
for sig in [signal.SIGTERM, signal.SIGINT, signal.SIGHUP, signal.SIGQUIT]:
  signal.signal(sig, handler)

def kill_process(proc):
  """
  Kills a process.
  """
  if proc.poll() is None:
    pid = proc.pid
    process = psutil.Process(pid)
    for p in process.get_children(recursive = True):
      try:
        p.kill()
      except psutil.NoSuchProcess:
	pass
    try:
      process.kill()
    except psutil.NoSuchProcess:
      pass

def clean():
  """
  Utility for (possibly) cleaning temporary files and stopping the solvers 
  execution at the end of the solving process (even when the termination is 
  forced externally).
  """
  for solver in RUNNING_SOLVERS:
    kill_process(solver.process)
  # Possibly remove temporary files.
  if not KEEP:
    for f in TMP_FILES:
      if os.path.exists(f):
	os.remove(f)

#def presolve(problem, static_sched, extractor, cores, pfolio_size):
  #"""
  #FIXME: Document.
  #Faccio correre ogni solver nell'ordine specificato dall'utente. E' quindi 
  #l'utente che si deve prendere cura di dosare l'allocazione dei solvers.
  #Quando l'ultimo solver termina finisce il pre_solving, ritornando 
  #una coppia (feat_vector, tempo impiegato).
  #L'estrazione delle features viene effettuata non appena c'e' un processore 
  #libero, nel caso vi siano piu' solver che processori.
  #Se static_schedule = [], semplicemente estrae le features (se n < m).
  #"""
  
  #if cores >= pfolio_size:
    ## If the number of specified cores execeeds the number of, no prediction is 
    ## needed: we simply allocate a core per solver.
    #return ([], 0)
  
  #start_time = time.time()
  #feat_extracted = False
  ## Controllo l'esecuzione dei solvers in esecuzione
  #while (running_solvers):
    #for solver in running_solvers:
      #gestisci_output(solver)
      #eventualmente_restart(solver)
      #if fails(solver):
        #rimuovere da static_schedule e pfolio!
      #if timeout(solver):
	#sospendi(solver)
	#static_schedule.remove(solver)
	#if static_schedule not empty:
	  #lancia_solver(static_schedule.pop(0)) # eventualm. resume
	#elif n < m and not feat_extracted:
	  #feat_vector = extract_features(pb)
	  #feat_extracted = True

  ## Ritorno feat_vector e il tempo impiegato per lo static	    
  #return (feat_vector, time.time() - start_time)

def run_schedule(schedule, problem, cores):
  """
  Runs (possibly in parallel on different cores) a schedule of solvers.
  """
  
  # Launch the mzn2fzn conversion.
  for _ in range(cores):
    if schedule:
      solver = schedule.pop(0)
      print '% Starting',solver.name(),'for',solver.timeout,'seconds'
      run_solver(solver, problem)
      
  # The actual solvers execution starts here.
  while RUNNING_SOLVERS:
    time.sleep(SLEEP_TIME)
    
    for solver in RUNNING_SOLVERS:
      # Read and process lines from the output stream of each process.
      lines = read_lines(solver.process)  
      if lines:
	process_output(solver, problem, lines)
      
      # Solver process terminated.
      if solver.process.poll() is not None:
	if solver.status == 'flatzinc':
	  # Sometimes not all the lines are read from solver output.
	  lines = read_lines(solver.process)  
          if lines:
	    process_output(solver, problem, lines)
        solver_terminated(solver, problem, schedule)
        continue
      
      # Expired timeout.
      if time.time() - solver.start_time > solver.timeout and \
	 time.time() - solver.solution_time > solver.wait_time:
	   kill_process(solver.process)
	   RUNNING_SOLVERS.remove(solver)
	   print '% Timeout expired for',solver.name()
	   if schedule:
             solver = schedule.pop(0)
             print '% Starting',solver.name(),'for',str(solver.timeout),'sec.'
             run_solver(solver, problem)
	   continue
	 
      # Restart a solver if its solution is obsolete.
      if solver.status == 'flatzinc' \
      and problem.bound_better_than(solver.obj_value) \
      and time.time() - solver.solution_time > solver.restart_time:
	kill_process(solver.process)
	RUNNING_SOLVERS.remove(solver)
	print '% Restarting',solver.name()
	solver.timeout = max(
	  solver.timeout - (time.time() - solver.start_time), 0
	)
	run_solver(solver, problem)
	continue

def run_solver(solver, problem):
  global RUNNING_SOLVERS
  if solver.status == 'ready':
    cmd = solver.mzn2fzn_cmd(problem)
    solver.status = 'mzn2fzn'
  elif solver.status == 'mzn2fzn':
    cmd = solver.flatzinc_cmd(problem)
    solver.status = 'flatzinc'
  elif solver.status == 'flatzinc':
    if problem.isCOP() and not solver.obj_var:
      # Extract and set the objective variable from the FlatZinc model.
      solver.set_obj_var()
    if solver.name == problem.best_solver or \
    problem.bound_better_than(solver.obj_value):
      # Restart solver with a better bound.
      bound = problem.best_bound
      print '% Injecting value',bound,'to',solver.name(),'FlatZinc model'
      solver.inject_bound(bound)
    cmd = solver.flatzinc_cmd(problem)
  #elif solver.status == 'suspended':
  else:
    print 'Unknown status',solver.status
    assert False
  
  if solver.status == 'flatzinc':
    solver.process = Popen(cmd, stdout = PIPE)
    fd = solver.process.stdout.fileno()
    fl = fcntl.fcntl(fd, fcntl.F_GETFL)
    fcntl.fcntl(fd, fcntl.F_SETFL, fl | os.O_NONBLOCK)
  else:
    solver.process = Popen(cmd)
  solver.start_time = time.time()
  solver.solution_time = time.time()
  RUNNING_SOLVERS.append(solver)

def read_lines(proc):
  """
  Returns the read lines of a process.
  """
  try:
    return proc.stdout.read()
  except:
    return ''

def process_output(solver, problem, lines):
  """
  Processes the output of a solver.
  """
  for line in lines.split('\n'):
    if line == '----------':
      if problem.isCSP():
	print '%',solver.name(),'found a solution'
	for s in solver.solution:
	  print s
	print line
	if '-a ' not in solver.fzn_options and ' -a ' not in solver.fzn_options:
	  print '% Search completed by',solver.name()
	  clean()
          sys.exit(0)
      elif problem.bound_worse_than(solver.obj_value):
	# The objective value found is the best so far.
	problem.best_bound = solver.obj_value
	print '%',solver.name(),'found a new solution'
	for s in solver.solution:
	  print s
	print line
	problem.best_solver = solver.name()
      solver.solution = []
      solver.solution_time = time.time()
    elif line == '==========' or line == '=====UNSATISFIABLE=====':
      if not problem.has_bound():
	print line
      else:
	print '=========='
      print '% Search completed by',solver.name()
      clean()
      sys.exit(0)
    elif ' = ' in line:
      if problem.aux_var in line:
	# Actual objective value.
	solver.obj_value = int(
	  line[line.index(' = ') + 3 : len(line)].split(';')[0]
	)
	line = '% ' + line
      solver.solution.append(line)
      solver.solution_time = time.time()

def solver_terminated(solver, problem, schedule):
  """
  Handles the termination of a solver process, possibly launching a new solver.
  """
  RUNNING_SOLVERS.remove(solver)
  if solver.status == 'mzn2fzn':
    if solver.process.returncode == 0:
      print '% MiniZinc model converted by ' + solver.name() + '.',
      timeout = max(solver.timeout - (time.time() - solver.start_time), 0)
      print 'Starting the FlatZinc execution for',str(timeout),'seconds'
      solver.timeout = timeout
      run_solver(solver, problem)
    else:
      print '% Error! MiniZinc model not converted by',solver.name()
      # Launch a new solver if any.
      for s in schedule:
	if s.name() == solver.name():
	  schedule.remove(s)
      if schedule:
	new_solver = schedule.pop(0)
	new_solver.timeout += solver.timeout + solver.start_time - time.time()
	print '% Starting',new_solver.name(),'for',str(new_solver.timeout),'sec'
	run_solver(new_solver, problem)
  else:
    if solver.process.returncode != 0:
      # Unexpected termination of solver execution.
      print '% Error: solver',solver.name(),'failed unexpectedly'
      for s in schedule:
	if s.name() == solver.name():
	  schedule.remove(s)
    # Launch a new solver if any.
    if schedule:
      new_solver = schedule.pop(0)
      new_solver.timeout += solver.timeout + solver.start_time - time.time()
      print '% Starting',new_solver.name(),'for',str(new_solver.timeout),'sec'
      run_solver(new_solver, problem)

def setup(problem, schedule, solver_options, tmp_dir):
  """
  Prepares the execution of a schedule by setting the proper parameters.
  """
  global TMP_FILES
  tmp_id = tmp_dir + '/' + gethostname() + '_' + str(os.getpid())
  ozn_path = tmp_id + '.ozn'
  problem.ozn_path = ozn_path
  TMP_FILES = [ozn_path]
  if problem.isCOP():
    # Make a copy of the original MiniZinc model.
    mzn_path = tmp_id + '.mzn'
    out_path = tmp_id + '.out'
    problem = problem.make_cpy(mzn_path, out_path, aux = True)
    TMP_FILES += [mzn_path, out_path]
  setup_schedule = []
  for (s, t) in schedule:
    fzn_path = tmp_id + '.' + s + '.fzn'
    opts = solver_options[s]['options']
    wt   = float(solver_options[s]['wait_time'])
    rt   = solver_options[s]['restart_time']
    solver = RunningSolver(eval(s), problem.solve, fzn_path, opts, wt, rt, t)
    setup_schedule.append(solver)
    TMP_FILES += [fzn_path]
  return problem, setup_schedule

def main(args):
  global KEEP
  problem, k, timeout, pfolio, backup, kb, lims, static_sched, extractor, \
  cores, solver_options, tmp_dir, KEEP = parse_arguments(args)

  try:
    #presolve(problem, static_sched, extractor, cores, len(pfolio))
    
    #clean()
    #sys.exit(0)
    print '% Extracting features...'
    feat_vector = extractor.extract_features([problem, lims])

    if not feat_vector:
      print '% Features extraction failed! Switching to backup solver(s).'
      dynamic_sched = [(s, float(timeout) / cores) for s in pfolio[:cores]]
    else:
      print '% Computing solvers schedule...'
      dynamic_sched = sunny(
        problem, pfolio, backup, feat_vector, k, timeout, kb
      )
      print '% SUNNY sequential schedule:',dynamic_sched
      
    par_sched = parallelize(static_sched, dynamic_sched, cores, timeout, pfolio)
    print '% SUNNY parallel schedule:',par_sched
    print '% Executing solvers...'
    problem, schedule = setup(problem, par_sched, solver_options, tmp_dir)
    run_schedule(schedule, problem, cores)
    
  except Exception as e:
    print >> sys.stderr, '% Unexpected Termination of sunny-cp.'
    clean()
    traceback.print_exc()
    sys.exit(1)
    
  print '% Search not completed by any constituent solver. Bye!'
  clean()
  
if __name__ == '__main__':
  main(sys.argv[1:])
