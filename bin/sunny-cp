#! /usr/bin/env python
'''
sunny-cp executable module.
'''

import os
import sys
import time
import fcntl
import psutil
import signal
import traceback
import multiprocessing
from string import replace
from socket import gethostname
from subprocess import Popen, PIPE

SUNNY_HOME = os.environ['SUNNY_HOME']
sys.path.append(SUNNY_HOME + '/src')
from problem        import *
from parsing        import *
from solver         import *
from features       import *
from scheduling     import *
from pfolio_solvers import *

# List of the running solvers.
RUNNING_SOLVERS = []
# If KEEP, don't delete temporary files.
KEEP = False
# List of temporary file paths.
TMP_FILES = []
# Sleep time (in seconds) for multiprocessing.
SLEEP_TIME = 0.1

def handler(signum = None, frame = None):
  """
  Handles termination signals.
  """
  print >> sys.stderr, '% Signal handler called with signal',signum
  clean()
  sys.stdout.close()
  sys.exit(signum)
for sig in [signal.SIGTERM, signal.SIGINT, signal.SIGHUP, signal.SIGQUIT]:
  signal.signal(sig, handler)

def kill_process(proc):
  """
  Kills a process.
  """
  if proc.poll() is None:
    pid = proc.pid
    process = psutil.Process(pid)
    for p in process.get_children(recursive = True):
      p.kill()
    process.kill()

def clean():
  """
  Utility for (possibly) cleaning temporary files and stopping the solvers 
  execution at the end of the solving process (even when the termination is 
  forced externally).
  """
  for solver in RUNNING_SOLVERS:
    kill_process(solver.process)
  # Possibly remove temporary files.
  if not KEEP:
    for f in TMP_FILES:
      if os.path.exists(f):
	os.remove(f)

def run_schedule(schedule, cores):
  """
  Runs (possibly in parallel on different cores) a schedule of solvers.
  """ 
  
  # Launch the mzn2fzn conversion.
  for _ in range(cores):
    if schedule:
      solver = schedule.pop(0)
      print '% Starting',solver.name(),'for',solver.timeout,'seconds'
      #FIXME: mzn2fzn(s, t)
  clean()    
  sys.exit(0)
  # The actual solvers execution starts here.
  while RUNNING_SOLVERS:
    time.sleep(SLEEP_TIME)
    
    for (solver, info) in RUNNING_SOLVERS.items():
      # Read and process lines from the output stream of each process.
      lines = read_lines(info)  
      if lines:
	process_output(solver, info, lines)
      
      # Solver process terminated or expired timeout.
      if info[PROCESS].poll() is not None:
	if info[CMD] == 'flatzinc':
	  # Sometimes not all the lines are read from solver output.
	  lines = read_lines(info)  
          if lines:
	    process_output(solver, info, lines)
        solver_terminated(solver, info, par_schedule)
      
      # Expired timeout.
      if time.time() - info[START_TIME] > info[TIMEOUT] and \
	 time.time() - info[SOLUTION_TIME] > wait_time:
	   solver_timeout(solver, par_schedule)
	   
      # Restart the solver if its solution is obsolete.
      if PROBLEM.bound_better_than(info[OBJ_VALUE]) and info[CMD] == 'flatzinc'\
      and time.time() - info[SOLUTION_TIME] > restart_time:
	kill_process(RUNNING_SOLVERS[solver][PROCESS])
	print '% Restarting',solver
	timeout = max(info[TIMEOUT] - (time.time() - info[START_TIME]), 0)
	flatzinc(solver, timeout)

def read_lines(info):
  """
  Returns the read lines of the process.
  """
  try:
    return info[PROCESS].stdout.read()
  except:
    return ''

def process_output(solver, info, lines):
  """
  Processes the output of a solver.
  """
  global RUNNING_SOLVERS, PROBLEM
  for line in lines.split('\n'):
    if line == '----------':
      if PROBLEM.isCSP():
	print '%',solver,'found a solution'
	for s in info[SOLUTION]:
	  print s
	print line
	clean()
        sys.exit(0)
      if PROBLEM.bound_worse_than(info[OBJ_VALUE]):
	# The objective value found is the best so far.
	PROBLEM.best_bound = info[OBJ_VALUE]
	print '%',solver,'found a new solution'
	for s in info[SOLUTION]:
	  print s
	print line
	PROBLEM.best_solver = solver
	RUNNING_SOLVERS[solver][SOLUTION] = []
      RUNNING_SOLVERS[solver][SOLUTION_TIME] = time.time()
    elif line == '==========' or line == '=====UNSATISFIABLE=====':
      if not PROBLEM.has_bound():
	print line
      else:
	print '=========='
      print '% Search completed by',solver
      clean()
      sys.exit(0)
    elif ' = ' in line:
      if PROBLEM.AUX_VAR in line:
	# Actual objective value.
	RUNNING_SOLVERS[solver][OBJ_VALUE] = int(
	  line[line.index(' = ') + 3 : len(line)].split(';')[0]
	)
	line = '% ' + line
      RUNNING_SOLVERS[solver][SOLUTION].append(line)
      RUNNING_SOLVERS[solver][SOLUTION_TIME] = time.time()

def solver_terminated(solver, info, par_schedule):
  """
  Handles the termination of a solver process.
  """
  if info[CMD] == 'mzn2fzn':
    if info[PROCESS].returncode == 0:
      print '% MiniZinc model converted by',solver + '.',
      timeout = max(info[TIMEOUT] - (time.time() - info[START_TIME]), 0)
      print 'Starting the FlatZinc execution for',str(timeout),'seconds'
      flatzinc(solver, timeout)
    else:
      print '% Error! MiniZinc model not converted by',solver
      fzn = PROBLEM.fzns[solver]
      if os.path.exists(fzn) and not PROBLEM.keep:
	os.remove(fzn)
      del RUNNING_SOLVERS[solver]
      # Launch a new solver if any.
      new_solver = None
      for i in range(0, len(par_schedule)):
	if par_schedule[i][0] == solver:
	  par_schedule.pop(i)
      if par_schedule:
	(new_solver, t) = par_schedule.pop(0)
	t += info[TIMEOUT] + info[START_TIME] - time.time()
	print '% Starting',new_solver,'for',str(t),'seconds'
	mzn2fzn(new_solver, t)
  else:
    # Unexpected termination of solver execution.
    print '% Error: solver',solver,'failed unexpectedly'
    fzn = PROBLEM.fzns[solver]
    if os.path.exists(fzn) and not PROBLEM.keep:
      os.remove(fzn)
    del RUNNING_SOLVERS[solver]
    # Launch a new solver if any.
    new_solver = None
    for i in range(0, len(par_schedule)):
      if par_schedule[i][0] == solver:
        par_schedule.pop(i)
    if par_schedule:
      (new_solver, t) = par_schedule.pop(0)
      t += info[TIMEOUT] + info[START_TIME] - time.time()
      print '% Starting',new_solver,'for',str(t),'seconds'
      mzn2fzn(new_solver, t)

def solver_timeout(solver, par_schedule):
  """
  Handles the timeout of a solver, possibly restarting a new one.
  """
  print '%',solver,'timeout'  
  global RUNNING_SOLVERS
  kill_process(RUNNING_SOLVERS[solver][PROCESS])
  if RUNNING_SOLVERS[solver][CMD] == 'mzn2fzn':
    fzn = PROBLEM.fzns[solver]
    if os.path.exists(fzn) and not PROBLEM.keep:
      os.remove(fzn)
    PROBLEM.fzns[solver] = ''
  del RUNNING_SOLVERS[solver]
  # Launch a new solver if any.
  if par_schedule:
    (new_solver, timeout) = par_schedule.pop(0)
    print '% Starting',new_solver,'for',str(timeout),'seconds'
    mzn2fzn(new_solver, timeout)

def mzn2fzn(solver, timeout):
  """
  Converts the MiniZinc model to the solver-specific FlatZinc model.
  """
  global RUNNING_SOLVERS
  solver = eval(solver + '()')
  name = solver.name
  RUNNING_SOLVERS[name] = {}
  RUNNING_SOLVERS[name][CMD] = 'mzn2fzn'
  RUNNING_SOLVERS[name][SOLUTION] = []
  RUNNING_SOLVERS[name][OBJ_VALUE] = PROBLEM.best_bound
  if PROBLEM.has_bound() and name != PROBLEM.best_solver:
    # Converts the MiniZinc model by using a better bound.
    bound = PROBLEM.best_bound
    print '% Injecting value',bound,'to MiniZinc model'
    PROBLEM.inject_bound_mzn(bound)
  RUNNING_SOLVERS[name][SOLUTION_TIME] = time.time()
  RUNNING_SOLVERS[name][TIMEOUT] = timeout
  RUNNING_SOLVERS[name][START_TIME] = time.time()
  if name in PROBLEM.fzns.keys():
    # The problem has already been successfully converted.
    flatzinc(name, timeout)
  else:
    fzn = PROBLEM.TMP_ID + '.' + name + '.fzn'
    PROBLEM.fzns[name] = fzn
    RUNNING_SOLVERS[name][PROCESS] = Popen(solver.mzn2fzn_cmd(PROBLEM, fzn))

def flatzinc(solver, timeout):
  """
  Executes the FlatZinc interpreter of a solver
  """
  global RUNNING_SOLVERS, PROBLEM
  solver = eval(solver + '()')
  name = solver.name
  RUNNING_SOLVERS[name][CMD] = 'flatzinc'
  RUNNING_SOLVERS[name][SOLUTION] = []
  if name not in PROBLEM.obj_vars.keys():
    # Extract the obj var from the FlatZinc model.
    with open(PROBLEM.fzns[name], 'r') as infile:
      for line in reversed(infile.readlines()):
	tokens = line.split()
	if 'solve' in tokens:
	  PROBLEM.obj_vars[name] = tokens[-1].replace(';', '')
	  break
  if name == PROBLEM.best_solver or \
    PROBLEM.bound_better_than(RUNNING_SOLVERS[name][OBJ_VALUE]):
      # Restarts solver with a better bound.
      bound = PROBLEM.best_bound
      print '% Injecting value',bound,'to',name,'FlatZinc model'
      PROBLEM.inject_bound_fzn(solver, bound)
      RUNNING_SOLVERS[name][OBJ_VALUE] = bound
  RUNNING_SOLVERS[name][SOLUTION_TIME] = time.time()
  RUNNING_SOLVERS[name][TIMEOUT] = timeout
  RUNNING_SOLVERS[name][START_TIME] = time.time()
  if os.path.exists(PROBLEM.fzns[name]):
    RUNNING_SOLVERS[name][PROCESS] = Popen(
      solver.flatzinc_cmd(PROBLEM), stdout = PIPE
    )
    # Non blocking read for processing output.
    fd = RUNNING_SOLVERS[name][PROCESS].stdout.fileno()
    fl = fcntl.fcntl(fd, fcntl.F_GETFL)
    fcntl.fcntl(fd, fcntl.F_SETFL, fl | os.O_NONBLOCK)

def setup_schedule(problem, par_sched, solver_options, tmp_dir):
  global TMP_FILES
  tmp_id = tmp_dir + '/' + gethostname() + '_' + str(os.getpid())
  if problem.isCOP():
    # Make a copy of the original MiniZinc model.
    mzn_path = tmp_id + '.mzn'
    out_path = tmp_id + '.out'
    problem = problem.make_cpy(mzn_path, out_path, aux = True)
    TMP_FILES += [mzn_path, out_path]
  schedule = []
  for (s, t) in par_sched:
    opts = solver_options[s]['options']
    wt   = solver_options[s]['wait_time']
    rt   = solver_options[s]['restart_time']
    solver = RunningSolver(eval(s), problem.solve, opts, wt, rt, t)
    schedule.append(solver)
  return schedule

def main(args):
  global KEEP
  problem, k, timeout, pfolio, backup, kb, lims, static_sched, extractor, \
  cores, solver_options, tmp_dir, KEEP = parse_arguments(args)

  try:
    print '% Extracting features...'
    feat_vector = extractor.extract_features([problem, lims])

    if not feat_vector:
      print '% Features extraction failed! Switching to backup solver(s).'
      dynamic_sched = [(s, float(timeout) / cores) for s in pfolio[:cores]]
    else:
      print '% Computing solvers schedule...'
      dynamic_sched = sunny(
        problem, pfolio, backup, feat_vector, k, timeout, kb
      )
      print '% SUNNY sequential schedule:',dynamic_sched
      
    par_sched = parallelize(static_sched, dynamic_sched, cores, timeout, pfolio)
    print '% SUNNY parallel schedule:',par_sched
    print '% Executing solvers...'
    print par_sched
    schedule = setup_schedule(problem, par_sched, solver_options, tmp_dir)
    run_schedule(schedule, cores)
    
  except Exception as e:
    print >> sys.stderr, '% Unexpected Termination of sunny-cp.'
    clean()
    traceback.print_exc()
    sys.exit(1)
    
  print '% Search not completed by any constituent solver. Bye!'
  clean()
  
if __name__ == '__main__':
  main(sys.argv[1:])
