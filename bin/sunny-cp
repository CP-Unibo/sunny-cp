#! /usr/bin/env python
'''
sunny-cp executable module.
'''

import os
import sys
import time
import fcntl
import psutil
import signal
import traceback
import multiprocessing
from string import replace
from subprocess import Popen, PIPE

SUNNY_HOME = os.environ['SUNNY_HOME']
sys.path.append(SUNNY_HOME + '/src')
from problem        import *
from parsing        import *
from features       import *
from scheduling     import *
from pfolio_solvers import *

# Global variables keeping track of the current problem and the running solvers.
PROBLEM = None
RUNNING_SOLVERS = {}

# RUNNING_SOLVERS Indexes.
CMD = 0
PROCESS = 1
START_TIME = 2
TIMEOUT = 3
SOLUTION_TIME =4
SOLUTION = 5
OBJ_VALUE = 6

# Sleep time (in seconds) for multiprocessing.
SLEEP_TIME = 0.1

def handler(signum = None, frame = None):
  """
  Handles termination signals.
  """
  print >> sys.stderr, '% Signal handler called with signal',signum
  clean()
  sys.stdout.close()
  sys.exit(signum)
for sig in [signal.SIGTERM, signal.SIGINT, signal.SIGHUP, signal.SIGQUIT]:
  signal.signal(sig, handler)

def kill_process(proc):
  """
  Kills a process.
  """
  if proc.poll() is None:
    pid = proc.pid
    process = psutil.Process(pid)
    for p in process.get_children(recursive = True):
      p.kill()
    process.kill()

def clean():
  """
  Utility for (possibly) cleaning temporary files and stopping the solvers 
  execution at the end of the solving process (even when the termination is 
  forced externally).
  """
  for info in RUNNING_SOLVERS.values():
    kill_process(info[PROCESS])
  # Possibly remove temporary files.
  if PROBLEM and not PROBLEM.keep:
    if os.path.exists(PROBLEM.mzn_cpy):
      os.remove(PROBLEM.mzn_cpy)
    if os.path.exists(PROBLEM.mzn_out_cpy):
      os.remove(PROBLEM.mzn_out_cpy)
    for f in PROBLEM.fzns.values():
      if os.path.exists(f):
        os.remove(f)
    if os.path.exists(PROBLEM.ozn):
      os.remove(PROBLEM.ozn)

def run_schedule(par_schedule, cores, wait_time, restart_time):
  """
  Runs (possibly in parallel on different cores) a schedule of solvers.
  """
  if PROBLEM.isCOP():
    # Make a copy of the original MiniZinc model.
    PROBLEM.make_mzn_cpy()
  
  # Launch the mzn2fzn conversion.
  for _ in range(cores):
    if par_schedule:
      (s, t) = par_schedule.pop(0)   
      print '% Starting',s,'for',str(t),'seconds'
      mzn2fzn(s, t)
  
  # The actual solvers execution starts here.
  while RUNNING_SOLVERS:
    time.sleep(SLEEP_TIME)
    
    for (solver, info) in RUNNING_SOLVERS.items():
      # Read and process lines from the output stream of each process.
      lines = read_lines(info)  
      if lines:
	process_output(solver, info, lines)
      
      # Solver process terminated or expired timeout.
      if info[PROCESS].poll() is not None:
        solver_terminated(solver, info, par_schedule)
      
      # Expired timeout.
      if time.time() - info[START_TIME] > info[TIMEOUT] and \
	 time.time() - info[SOLUTION_TIME] > wait_time:
	   solver_timeout(solver, par_schedule)
	   
      # Restart the solver if its solution is obsolete.
      if PROBLEM.bound_better_than(info[OBJ_VALUE]) and info[CMD] == 'flatzinc'\
      and time.time() - info[SOLUTION_TIME] > restart_time:
	   kill_process(RUNNING_SOLVERS[solver][PROCESS])
	   print '% Restarting',solver
	   timeout = max(info[TIMEOUT] - (time.time() - info[START_TIME]), 0)
	   flatzinc(solver, timeout)

def read_lines(info):
  """
  Returns the read lines of the process.
  """
  try:
    return info[PROCESS].stdout.read()
  except:
    return ''

def process_output(solver, info, lines):
  """
  Processes the output of a solver.
  """
  global RUNNING_SOLVERS, PROBLEM
  for line in lines.split('\n'):
    if line == '----------':
      if PROBLEM.isCSP():
	print '%',solver,'found a solution'
	for s in info[SOLUTION]:
	  print s
	print line
	clean()
        sys.exit(0)
      if PROBLEM.bound_worse_than(info[OBJ_VALUE]):
	# The objective value found is the best so far.
	PROBLEM.best_bound = info[OBJ_VALUE]
	print '%',solver,'found a new solution'
	for s in info[SOLUTION]:
	  print s
	print line
	PROBLEM.best_solver = solver
	RUNNING_SOLVERS[solver][SOLUTION] = []
      RUNNING_SOLVERS[solver][SOLUTION_TIME] = time.time()
    elif line == '==========' or line == '=====UNSATISFIABLE=====':
      if not PROBLEM.has_bound():
	print line
      else:
	print '=========='
      print '% Search completed by',solver
      clean()
      sys.exit(0)
    elif ' = ' in line:
      if PROBLEM.AUX_VAR in line:
	# Actual objective value.
	RUNNING_SOLVERS[solver][OBJ_VALUE] = int(
	  line[line.index(' = ') + 3 : len(line)].split(';')[0]
	)
	line = '% ' + line
      RUNNING_SOLVERS[solver][SOLUTION].append(line)
      RUNNING_SOLVERS[solver][SOLUTION_TIME] = time.time()

def solver_terminated(solver, info, par_schedule):
  """
  Handles the termination of a solver process.
  """
  if info[CMD] == 'mzn2fzn':
    if info[PROCESS].returncode == 0:
      print '% MiniZinc model converted by',solver + '.',
      timeout = max(info[TIMEOUT] - (time.time() - info[START_TIME]), 0)
      print 'Starting the FlatZinc execution for',str(timeout),'seconds'
      flatzinc(solver, timeout)
    else:
      print '% Error! MiniZinc model not converted by',solver
      del RUNNING_SOLVERS[solver]
      # Launch a new solver if any.
      new_solver = None
      for i in range(0, len(par_schedule)):
	if par_schedule[i][0] == solver:
	  par_schedule.pop(i)
      if par_schedule:
	(new_solver, t) = par_schedule.pop(0)
	t += info[TIMEOUT] + info[START_TIME] - time.time()
	print '% Starting',new_solver,'for',str(t),'seconds'
	mzn2fzn(new_solver, t)
  else:
    # Unexpected termination of solver execution.
    print '% Error: solver',solver,'failed unexpectedly'
    del RUNNING_SOLVERS[solver]
    # Launch a new solver if any.
    new_solver = None
    for i in range(0, len(par_schedule)):
      if par_schedule[i][0] == solver:
        par_schedule.pop(i)
    if par_schedule:
      t += info[TIMEOUT] + info[START_TIME] - time.time()
      print '% Starting',new_solver,'for',str(t),'seconds'
      mzn2fzn(new_solver, t)

def solver_timeout(solver, par_schedule):
  """
  Handles the timeout of a solver, possibly restarting a new one.
  """
  print '%',solver,'timeout'  
  global RUNNING_SOLVERS
  kill_process(RUNNING_SOLVERS[solver][PROCESS])
  if RUNNING_SOLVERS[solver][CMD] == 'mzn2fzn':
    PROBLEM.fzns[solver] = ''
  del RUNNING_SOLVERS[solver]
  # Launch a new solver if any.
  if par_schedule:
    (new_solver, timeout) = par_schedule.pop(0)
    print '% Starting',new_solver,'for',str(timeout),'seconds'
    mzn2fzn(new_solver, timeout)

def mzn2fzn(solver, timeout):
  """
  Converts the MiniZinc model to the solver-specific FlatZinc model.
  """
  global RUNNING_SOLVERS
  solver = eval(solver + '()')
  name = solver.name
  RUNNING_SOLVERS[name] = {}
  RUNNING_SOLVERS[name][CMD] = 'mzn2fzn'
  RUNNING_SOLVERS[name][SOLUTION] = []
  RUNNING_SOLVERS[name][OBJ_VALUE] = PROBLEM.best_bound
  if PROBLEM.has_bound() and name != PROBLEM.best_solver:
    # Converts the MiniZinc model by using a better bound.
    bound = PROBLEM.best_bound
    print '% Injecting value',bound,'to MiniZinc model'
    PROBLEM.inject_bound_mzn(bound)
  RUNNING_SOLVERS[name][SOLUTION_TIME] = time.time()
  RUNNING_SOLVERS[name][TIMEOUT] = timeout
  RUNNING_SOLVERS[name][START_TIME] = time.time()
  if name in PROBLEM.fzns.keys():
    # The problem has already been successfully converted.
    flatzinc(name, timeout)
  else:
    fzn = PROBLEM.TMP_ID + '.' + name + '.fzn'
    PROBLEM.fzns[name] = fzn
    RUNNING_SOLVERS[name][PROCESS] = Popen(solver.mzn2fzn_cmd(PROBLEM, fzn))

def flatzinc(solver, timeout):
  """
  Executes the FlatZinc interpreter of a solver
  """
  global RUNNING_SOLVERS, PROBLEM
  solver = eval(solver + '()')
  name = solver.name
  RUNNING_SOLVERS[name][CMD] = 'flatzinc'
  RUNNING_SOLVERS[name][SOLUTION] = []
  if name not in PROBLEM.obj_vars.keys():
    # Extract the obj var from the FlatZinc model.
    with open(PROBLEM.fzns[name], 'r') as infile:
      for line in reversed(infile.readlines()):
	tokens = line.split()
	if 'solve' in tokens:
	  PROBLEM.obj_vars[name] = tokens[-1].replace(';', '')
	  break
  if name == PROBLEM.best_solver or \
    PROBLEM.bound_better_than(RUNNING_SOLVERS[name][OBJ_VALUE]):
      # Restarts solver with a better bound.
      bound = PROBLEM.best_bound
      print '% Injecting value',bound,'to',name,'FlatZinc model'
      PROBLEM.inject_bound_fzn(solver, bound)
      RUNNING_SOLVERS[name][OBJ_VALUE] = bound
  RUNNING_SOLVERS[name][SOLUTION_TIME] = time.time()
  RUNNING_SOLVERS[name][TIMEOUT] = timeout
  RUNNING_SOLVERS[name][START_TIME] = time.time()
  RUNNING_SOLVERS[name][PROCESS] = Popen(
    solver.flatzinc_cmd(PROBLEM), stdout = PIPE
  )
  # Non blocking read for processing output.
  fd = RUNNING_SOLVERS[name][PROCESS].stdout.fileno()
  fl = fcntl.fcntl(fd, fcntl.F_GETFL)
  fcntl.fcntl(fd, fcntl.F_SETFL, fl | os.O_NONBLOCK)

def main(args):
  global PROBLEM
  PROBLEM, k, timeout, pfolio, backup, kb, lims, static_sched, extractor, \
  cores, wait_time, restart_time = parse_arguments(args)
  
  try:
    print '% Extracting features...'
    feat_vector = extractor.extract_features([PROBLEM, lims])
  
    if not feat_vector:
      print '% Features extraction failed! Switching to backup solver(s).'
      dynamic_sched = [(s, float(timeout) / cores) for s in pfolio[0 : cores]]
    else:
      print '% Computing solvers schedule...'
      dynamic_sched = sunny(
        PROBLEM, pfolio, backup, feat_vector, k, timeout, kb
      )
      print '% SUNNY sequential schedule:',dynamic_sched
      
    par_sched = parallelize(static_sched, dynamic_sched, cores, timeout, pfolio)
    print '% SUNNY parallel schedule:',par_sched
    print '% Executing solvers...'
    run_schedule(par_sched, cores, wait_time, restart_time)
    
  except Exception as e:
    print >> sys.stderr, '% Unexpected Termination of sunny-cp.'
    clean()
    traceback.print_exc()
    sys.exit(1)
    
  print '% Search not completed by any constituent solver. Bye!'
  clean()
  
if __name__ == '__main__':
  main(sys.argv[1:])
