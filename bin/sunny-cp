#! /usr/bin/env python
'''
sunny-cp executable module.
'''

import os
import sys
import time
import fcntl
import psutil
import signal
import traceback
import multiprocessing
from string import replace
from socket import gethostname
from subprocess import PIPE

SUNNY_HOME = os.environ['SUNNY_HOME']
sys.path.append(SUNNY_HOME + '/src')
from problem        import *
from parsing        import *
from solver         import *
from features       import *
from scheduling     import *
from pfolio_solvers import *

# List of the running solvers.
RUNNING_SOLVERS = []
# If KEEP, don't delete temporary files.
KEEP = False
# List of temporary file paths.
TMP_FILES = []
# Sleep time (in seconds) for multiprocessing.
SLEEP_TIME = 0.1

def handler(signum = None, frame = None):
  """
  Handles termination signals.
  """
  print >> sys.stderr, '% Signal handler called with signal',signum
  clean()
  sys.stdout.close()
  sys.exit(signum)
for sig in [signal.SIGTERM, signal.SIGINT, signal.SIGHUP, signal.SIGQUIT]:
  signal.signal(sig, handler)

def kill_process(proc):
  """
  Kills a process.
  """
  if proc.poll() is None:
    pid = proc.pid
    for p in proc.children(recursive = True):
      try:
        p.kill()
      except psutil.NoSuchProcess:
	pass
    try:
      proc.kill()
    except psutil.NoSuchProcess:
      pass

def clean():
  """
  Utility for (possibly) cleaning temporary files and stopping the solvers 
  execution at the end of the solving process (even when the termination is 
  forced externally).
  """
  for solver in RUNNING_SOLVERS:
    kill_process(solver.process)
  # Possibly remove temporary files.
  if not KEEP:
    for f in TMP_FILES:
      if os.path.exists(f):
        os.remove(f)

def run_schedule(
  schedule, problem, cores, presolve = False, extractor = None, lims = None
):
  """
  Runs (possibly in parallel on different cores) a schedule of solvers.
  Note that this function is used for both the static and the dynamic schedule.
  If it is used for static schedule, the flag "presolve" must be set to True. 
  If presolve = True, it is also possible to perform the feature extraction by 
  setting the "extractor" and "lims" parameters. Feature extraction is performed 
  as soon as a free core is available. 
  If presolve = True this function returns a pair (t, f) where:
    - t is the time taken by the presolve phase
    - f is the (possibly empty) feature vector of the problem
  """
  if presolve:
    start_time = time.time()
    feat_vector = []
    if extractor:
      feat_extracted = False
    
  # Launch the solvers.
  for _ in range(cores):
    if schedule:
      solver = schedule.pop(0)
      print '% Starting',solver.name(),'for',solver.timeout,'seconds'
      run_solver(solver, problem)
      
  # Loop for dealing with runnning solvers.
  while (extractor and not feat_extracted) or RUNNING_SOLVERS:
    time.sleep(SLEEP_TIME)
    
    if extractor and not feat_extracted and len(RUNNING_SOLVERS) < cores:
      print '% Extracting features...'
      feat_vector = extractor.extract_features([problem, lims])
      feat_extracted = True
    
    for solver in RUNNING_SOLVERS:
      if solver.process.memory_percent() > solver.max_memory:
	print '% Error!',solver.name(),'exceeded the maximum allowed memory'
	solver_terminated(solver, problem, schedule)
	continue
      
      # Read and process lines from the output stream of each process.
      lines = read_lines(solver.process)  
      if lines:
	process_output(solver, problem, lines)
      
      # Solver process terminated.
      if solver.process.poll() is not None:
	if solver.status == 'flatzinc':
	  # Sometimes not all the lines are read from solver output.
	  lines = read_lines(solver.process)  
          if lines:
	    process_output(solver, problem, lines)
        solver_terminated(solver, problem, schedule)
        continue
      
      # Expired timeout.
      if time.time() - solver.start_time > solver.timeout and \
	 time.time() - solver.solution_time > solver.wait_time:
	   kill_process(solver.process)
	   RUNNING_SOLVERS.remove(solver)
	   print '% Timeout expired for',solver.name()
	   if schedule:
             solver = schedule.pop(0)
             if solver.timeout == 0:
	       # FIXME: In this case, all the scheduled solvers have been run 
	       # (or are running on another core) while the removed solver ran 
	       # out of time. There is still (at least) a solver that never run, 
	       # but we don't know how much time assign to it. This happens when 
	       # the global timeout T is reached. However, note that T refers to 
	       # the timeout of SUNNY algorithm and not of the solving process.
	       # At the moment we simply ignore that solver (and all subsequent 
	       # solvers). Alternative choices?
	       schedule = []
	     else:
               print '% Starting',solver.name(),'for',str(solver.timeout),'sec.'
               run_solver(solver, problem)
	   continue
	 
      # Restart a solver if its solution is obsolete.
      if solver.status == 'flatzinc' \
      and problem.bound_better_than(solver.obj_value) \
      and time.time() - solver.solution_time > solver.restart_time:
	kill_process(solver.process)
	RUNNING_SOLVERS.remove(solver)
	print '% Restarting',solver.name()
	solver.timeout = max(
	  solver.timeout - (time.time() - solver.start_time), 0
	)
	run_solver(solver, problem)
	continue

  if presolve:
    return feat_vector, time.time() - start_time

def run_solver(solver, problem):
  """
  Executes a solver according to its status.
  """
  global RUNNING_SOLVERS
  
  if solver.status == 'ready':
    cmd = solver.mzn2fzn_cmd(problem)
    solver.status = 'mzn2fzn'
  elif solver.status == 'mzn2fzn':
    cmd = solver.flatzinc_cmd(problem)
    solver.status = 'flatzinc'
  elif solver.status == 'flatzinc':
    if problem.isCOP() and not solver.obj_var:
      # Extract and set the objective variable from the FlatZinc model.
      solver.set_obj_var()
    if solver.name == problem.best_solver or \
    problem.bound_better_than(solver.obj_value):
      # Restart solver with a better bound.
      bound = problem.best_bound
      print '% Injecting value',bound,'to',solver.name(),'FlatZinc model'
      solver.inject_bound(bound)
    cmd = solver.flatzinc_cmd(problem)
  #elif solver.status == 'suspended':
  else:
    print 'Unknown status',solver.status
    assert False
  
  if solver.status == 'flatzinc':
    solver.process = psutil.Popen(cmd, stdout = PIPE)
    # For non-blocking read.
    fd = solver.process.stdout.fileno()
    fl = fcntl.fcntl(fd, fcntl.F_GETFL)
    fcntl.fcntl(fd, fcntl.F_SETFL, fl | os.O_NONBLOCK)
  else:
    solver.process = psutil.Popen(cmd)
    
  solver.start_time = time.time()
  solver.solution_time = time.time()
  RUNNING_SOLVERS.append(solver)

def read_lines(proc):
  """
  Returns the read lines of a process.
  """
  try:
    return proc.stdout.read()
  except:
    return ''

def process_output(solver, problem, lines):
  """
  Processes the output of a solver.
  """
  for line in lines.split('\n'):
    if line == '----------':
      if problem.isCSP():
	print '%',solver.name(),'found a solution'
	for s in solver.solution:
	  print s
	print line
	if '-a ' not in solver.fzn_options and ' -a ' not in solver.fzn_options:
	  print '% Search completed by',solver.name()
	  clean()
          sys.exit(0)
      elif problem.bound_worse_than(solver.obj_value):
	# The objective value found is the best so far.
	problem.best_bound = solver.obj_value
	print '%',solver.name(),'found a new solution'
	for s in solver.solution:
	  print s
	print line
	problem.best_solver = solver.name()
      solver.solution = []
      solver.solution_time = time.time()
    elif line == '==========' or line == '=====UNSATISFIABLE=====':
      if not problem.has_bound():
	print line
      else:
	print '=========='
      print '% Search completed by',solver.name()
      clean()
      sys.exit(0)
    elif ' = ' in line:
      if problem.aux_var in line:
	# Actual objective value.
	solver.obj_value = int(
	  line[line.index(' = ') + 3 : len(line)].split(';')[0]
	)
	line = '% ' + line
      solver.solution.append(line)
      solver.solution_time = time.time()

def solver_terminated(solver, problem, schedule):
  """
  Handles the termination of a solver process, possibly launching a new solver.
  """
  RUNNING_SOLVERS.remove(solver)
  if solver.status == 'mzn2fzn':
    if solver.process.returncode == 0:
      print '% MiniZinc model converted by ' + solver.name() + '.',
      timeout = max(solver.timeout - (time.time() - solver.start_time), 0)
      print 'Starting the FlatZinc execution for',str(timeout),'seconds'
      solver.timeout = timeout
      run_solver(solver, problem)
    else:
      print '% Error! MiniZinc model not converted by',solver.name()
      # Launch a new solver if any.
      for s in schedule:
	if s.name() == solver.name():
	  schedule.remove(s)
      if schedule:
	new_solver = schedule.pop(0)
	new_solver.timeout += solver.timeout + solver.start_time - time.time()
	print '% Starting',new_solver.name(),'for',str(new_solver.timeout),'sec'
	run_solver(new_solver, problem)
  else:
    if solver.process.returncode != 0:
      # Premature termination of solver execution.
      print '% Solver',solver.name(),'failed prematurely'
      for s in schedule:
	if s.name() == solver.name():
	  schedule.remove(s)
    # Launch a new solver if any.
    if schedule:
      new_solver = schedule.pop(0)
      new_solver.timeout += solver.timeout + solver.start_time - time.time()
      print '% Starting',new_solver.name(),'for',str(new_solver.timeout),'sec'
      run_solver(new_solver, problem)

def init_problem(problem, tmp_id):
  """
  Initializes a problem, making it ready to be solved.
  """
  global TMP_FILES
  ozn_path = tmp_id + '.ozn'
  problem.ozn_path = ozn_path
  TMP_FILES = [ozn_path]
  if problem.isCOP():
    # Make a copy of the original MiniZinc model.
    mzn_path = tmp_id + '.mzn'
    out_path = tmp_id + '.out'
    problem = problem.make_cpy(mzn_path, out_path, aux = True)
    TMP_FILES += [mzn_path, out_path]
  return problem

def init_schedule(schedule, solver_options, solve, tmp_id):
  """
  Initializes a schedule, making it ready to be executed.
  """
  global TMP_FILES
  running_schedule = []  
  for (s, t) in schedule:
    fzn_path = tmp_id + '.' + s + '.fzn'
    opts = solver_options[s]['options']
    wt   = float(solver_options[s]['wait_time'])
    rt   = solver_options[s]['restart_time']
    mem  = solver_options[s]['max_memory']
    solver = RunningSolver(eval(s), solve, fzn_path, opts, wt, rt, mem, t)
    running_schedule.append(solver)
    TMP_FILES.append(fzn_path)
  return running_schedule

def main(args):
  try:
    # Initialization.
    global KEEP
    problem, k, timeout, pfolio, backup, kb, lims, static, extractor, cores, \
    solver_options, tmp_dir, KEEP = parse_arguments(args)
  
    tmp_id = tmp_dir + '/' + gethostname() + '_' + str(os.getpid())
    problem = init_problem(problem, tmp_id)
    static  = init_schedule(static, solver_options, problem.solve, tmp_id)
    print '% Pre-solving...'
    if cores >= len(pfolio):
      # If the number of specified cores execeeds the portfolio size, then no 
      # prediction is needed: we simply allocate a core per solver.
      print '% Features extraction not needed!'
      extractor = None
      lims = None
    feat_vector, static_time = run_schedule(
      static, problem, cores, True, extractor, lims
    )
    if not feat_vector:
      if extractor:
        print '% Features extraction failed! Switching to backup solver(s).'
      dynamic_sched = [(s, float(timeout) / cores) for s in pfolio[:cores]]
    else:
      timeout -= round(static_time)
      print '% Computing solvers schedule...'
      #TODO: From Here. Consider that if len(seq_schedule) <= cores, then all 
      # the solvers in parallel + possible padding with not_scheduled.
      # Parallelization is useless if num solvers <= cores (edit parallelize).
      dynamic_sched = sunny(
        problem, pfolio, backup, feat_vector, k, timeout, kb
      )
      print '% SUNNY sequential schedule:',dynamic_sched
    par_sched = parallelize([], dynamic_sched, cores, timeout, pfolio)
    print '% SUNNY parallel schedule:',par_sched
    # Solving.
    print '% Solving...'
    schedule = init_schedule(par_sched, solver_options, problem.solve, tmp_dir)
    run_schedule(schedule, problem, cores)
    
  except Exception as e:
    print >> sys.stderr, '% Unexpected Termination of sunny-cp.'
    clean()
    traceback.print_exc()
    sys.exit(1)
    
  print '% Search not completed by any constituent solver. Bye!'
  clean()
  
if __name__ == '__main__':
  main(sys.argv[1:])
